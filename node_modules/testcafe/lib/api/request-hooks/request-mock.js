"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hook_1 = __importDefault(require("./hook"));
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const runtime_1 = require("../../errors/runtime");
const types_1 = require("../../errors/types");
const warning_message_1 = __importDefault(require("../../notifications/warning-message"));
class RequestMock extends hook_1.default {
    constructor() {
        super([]);
        this._pendingRequestFilterRuleInit = null;
        this._mocks = new Map();
    }
    async onRequest(event) {
        const mock = this._mocks.get(event._requestFilterRule.id);
        await event.setMock(mock);
    }
    async onResponse(event) {
        var _a;
        if (event.isSameOriginPolicyFailed)
            (_a = this._warningLog) === null || _a === void 0 ? void 0 : _a.addWarning(warning_message_1.default.requestMockCORSValidationFailed, RequestMock.name, event._requestFilterRule);
    }
    // API
    onRequestTo(requestFilterRuleInit) {
        if (this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('onRequestTo', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'respond' method was not called after 'onRequestTo'. You must call the 'respond' method to provide the mocked response.");
        this._pendingRequestFilterRuleInit = requestFilterRuleInit;
        return this;
    }
    respond(body, statusCode, headers) {
        if (!this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('respond', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'onRequestTo' method was not called before 'respond'. You must call the 'onRequestTo' method to provide the URL requests to which are mocked.");
        const mock = new testcafe_hammerhead_1.ResponseMock(body, statusCode, headers);
        const rule = new testcafe_hammerhead_1.RequestFilterRule(this._pendingRequestFilterRuleInit);
        this._requestFilterRules.push(rule);
        this._mocks.set(rule.id, mock);
        this._pendingRequestFilterRuleInit = null;
        return this;
    }
}
function createRequestMock() {
    return new RequestMock();
}
exports.default = createRequestMock;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1tb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS9yZXF1ZXN0LWhvb2tzL3JlcXVlc3QtbW9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtEQUFpQztBQUVqQyw2REFNNkI7QUFFN0Isa0RBQWdEO0FBQ2hELDhDQUFvRDtBQUNwRCwwRkFBa0U7QUFHbEUsTUFBTSxXQUFZLFNBQVEsY0FBVztJQUlqQztRQUNJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVWLElBQUksQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLENBQUM7UUFDMUMsSUFBSSxDQUFDLE1BQU0sR0FBMEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRU0sS0FBSyxDQUFDLFNBQVMsQ0FBRSxLQUFtQjtRQUN2QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFpQixDQUFDO1FBRTFFLE1BQU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFvQjs7UUFDekMsSUFBSSxLQUFLLENBQUMsd0JBQXdCO1lBQzlCLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsVUFBVSxDQUFDLHlCQUFlLENBQUMsK0JBQStCLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUU7SUFDbEksQ0FBQztJQUVELE1BQU07SUFDQyxXQUFXLENBQUUscUJBQTRDO1FBQzVELElBQUksSUFBSSxDQUFDLDZCQUE2QjtZQUNsQyxNQUFNLElBQUksa0JBQVEsQ0FBQyxhQUFhLEVBQUUsc0JBQWMsQ0FBQyw0QkFBNEIsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLDZIQUE2SCxDQUFDLENBQUM7UUFFcE8sSUFBSSxDQUFDLDZCQUE2QixHQUFHLHFCQUFxQixDQUFDO1FBRTNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxPQUFPLENBQUUsSUFBdUIsRUFBRSxVQUFtQixFQUFFLE9BQWdCO1FBQzFFLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCO1lBQ25DLE1BQU0sSUFBSSxrQkFBUSxDQUFDLFNBQVMsRUFBRSxzQkFBYyxDQUFDLDRCQUE0QixFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsbUpBQW1KLENBQUMsQ0FBQztRQUV0UCxNQUFNLElBQUksR0FBRyxJQUFJLGtDQUFZLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN6RCxNQUFNLElBQUksR0FBRyxJQUFJLHVDQUFpQixDQUFDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUvQixJQUFJLENBQUMsNkJBQTZCLEdBQUcsSUFBSSxDQUFDO1FBRTFDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSjtBQUVELFNBQXdCLGlCQUFpQjtJQUNyQyxPQUFPLElBQUksV0FBVyxFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUZELG9DQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlcXVlc3RIb29rIGZyb20gJy4vaG9vayc7XG5cbmltcG9ydCB7XG4gICAgUmVzcG9uc2VNb2NrLFxuICAgIFJlcXVlc3RFdmVudCxcbiAgICBSZXNwb25zZUV2ZW50LFxuICAgIFJlcXVlc3RGaWx0ZXJSdWxlSW5pdCxcbiAgICBSZXF1ZXN0RmlsdGVyUnVsZVxufSBmcm9tICd0ZXN0Y2FmZS1oYW1tZXJoZWFkJztcblxuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgV0FSTklOR19NRVNTQUdFIGZyb20gJy4uLy4uL25vdGlmaWNhdGlvbnMvd2FybmluZy1tZXNzYWdlJztcblxuXG5jbGFzcyBSZXF1ZXN0TW9jayBleHRlbmRzIFJlcXVlc3RIb29rIHtcbiAgICBwcml2YXRlIF9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0OiBudWxsIHwgUmVxdWVzdEZpbHRlclJ1bGVJbml0O1xuICAgIHByaXZhdGUgX21vY2tzOiBNYXA8c3RyaW5nLCBSZXNwb25zZU1vY2s+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgc3VwZXIoW10pO1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0RmlsdGVyUnVsZUluaXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb2NrcyAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBvblJlcXVlc3QgKGV2ZW50OiBSZXF1ZXN0RXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbW9jayA9IHRoaXMuX21vY2tzLmdldChldmVudC5fcmVxdWVzdEZpbHRlclJ1bGUuaWQpIGFzIFJlc3BvbnNlTW9jaztcblxuICAgICAgICBhd2FpdCBldmVudC5zZXRNb2NrKG1vY2spO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBvblJlc3BvbnNlIChldmVudDogUmVzcG9uc2VFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoZXZlbnQuaXNTYW1lT3JpZ2luUG9saWN5RmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5fd2FybmluZ0xvZz8uYWRkV2FybmluZyhXQVJOSU5HX01FU1NBR0UucmVxdWVzdE1vY2tDT1JTVmFsaWRhdGlvbkZhaWxlZCwgUmVxdWVzdE1vY2submFtZSwgZXZlbnQuX3JlcXVlc3RGaWx0ZXJSdWxlKTtcbiAgICB9XG5cbiAgICAvLyBBUElcbiAgICBwdWJsaWMgb25SZXF1ZXN0VG8gKHJlcXVlc3RGaWx0ZXJSdWxlSW5pdDogUmVxdWVzdEZpbHRlclJ1bGVJbml0KTogUmVxdWVzdE1vY2sge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcignb25SZXF1ZXN0VG8nLCBSVU5USU1FX0VSUk9SUy5yZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yLCBSZXF1ZXN0TW9jay5uYW1lLCBcIlRoZSAncmVzcG9uZCcgbWV0aG9kIHdhcyBub3QgY2FsbGVkIGFmdGVyICdvblJlcXVlc3RUbycuIFlvdSBtdXN0IGNhbGwgdGhlICdyZXNwb25kJyBtZXRob2QgdG8gcHJvdmlkZSB0aGUgbW9ja2VkIHJlc3BvbnNlLlwiKTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0ID0gcmVxdWVzdEZpbHRlclJ1bGVJbml0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyByZXNwb25kIChib2R5OiBzdHJpbmcgfCBGdW5jdGlvbiwgc3RhdHVzQ29kZT86IG51bWJlciwgaGVhZGVycz86IG9iamVjdCk6IFJlcXVlc3RNb2NrIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKCdyZXNwb25kJywgUlVOVElNRV9FUlJPUlMucmVxdWVzdEhvb2tDb25maWd1cmVBUElFcnJvciwgUmVxdWVzdE1vY2submFtZSwgXCJUaGUgJ29uUmVxdWVzdFRvJyBtZXRob2Qgd2FzIG5vdCBjYWxsZWQgYmVmb3JlICdyZXNwb25kJy4gWW91IG11c3QgY2FsbCB0aGUgJ29uUmVxdWVzdFRvJyBtZXRob2QgdG8gcHJvdmlkZSB0aGUgVVJMIHJlcXVlc3RzIHRvIHdoaWNoIGFyZSBtb2NrZWQuXCIpO1xuXG4gICAgICAgIGNvbnN0IG1vY2sgPSBuZXcgUmVzcG9uc2VNb2NrKGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICAgICAgICBjb25zdCBydWxlID0gbmV3IFJlcXVlc3RGaWx0ZXJSdWxlKHRoaXMuX3BlbmRpbmdSZXF1ZXN0RmlsdGVyUnVsZUluaXQpO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3RGaWx0ZXJSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLl9tb2Nrcy5zZXQocnVsZS5pZCwgbW9jayk7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0TW9jayAoKTogUmVxdWVzdE1vY2sge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdE1vY2soKTtcbn1cbiJdfQ==