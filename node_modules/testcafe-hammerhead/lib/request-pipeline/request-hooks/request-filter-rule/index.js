"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const generate_unique_id_1 = __importDefault(require("../../../utils/generate-unique-id"));
const stringify_1 = __importDefault(require("./stringify"));
const DEFAULT_OPTIONS = {
    url: void 0,
    method: void 0,
    isAjax: void 0
};
const MATCH_ANY_REQUEST_REG_EX = /.*/;
// NOTE: RequestFilterRule is a data transfer object
// It should contain only initialization and creation logic
class RequestFilterRule {
    constructor(options) {
        this.options = this._initializeOptions(options);
        this.id = this._initializeId(this.options);
    }
    _initializeOptions(options) {
        let tmpOptions = Object.assign({}, DEFAULT_OPTIONS);
        if (typeof options === 'string' || lodash_1.isRegExp(options))
            tmpOptions.url = options;
        else if (typeof options === 'function')
            tmpOptions = options;
        else if (typeof options === 'object')
            tmpOptions = Object.assign(tmpOptions, options);
        else
            throw new TypeError('Wrong options have been passed to a request filter.');
        if (typeof tmpOptions.method === 'string')
            tmpOptions.method = tmpOptions.method.toLowerCase();
        return tmpOptions;
    }
    _initializeId(options) {
        let id = generate_unique_id_1.default();
        if (lodash_1.isObject(options) && lodash_1.isString(options['id'])) {
            id = options['id'];
            delete options['id'];
        }
        return id;
    }
    static _isRequestFilterRuleLike(rule) {
        return !!rule['id'] && !!rule['options'];
    }
    static _ensureRule(rule) {
        if (rule instanceof RequestFilterRule)
            return rule;
        else if (RequestFilterRule._isRequestFilterRuleLike(rule)) {
            const id = rule['id'];
            const options = rule['options'];
            const newOptions = Object.assign({}, { id }, options);
            return new RequestFilterRule(newOptions);
        }
        return new RequestFilterRule(rule);
    }
    static get ANY() {
        return new RequestFilterRule(MATCH_ANY_REQUEST_REG_EX);
    }
    static isANY(instance) {
        return !!(instance &&
            instance.options &&
            instance.options.url === MATCH_ANY_REQUEST_REG_EX);
    }
    static from(rules) {
        if (!rules)
            return [];
        const ruleArr = lodash_1.castArray(rules);
        return ruleArr.map(rule => this._ensureRule(rule));
    }
    toString() {
        return stringify_1.default(this);
    }
}
exports.default = RequestFilterRule;module.exports = exports.default;

